#include <iostream>           // Підключення стандартної бібліотеки вводу/виводу.
// Цей заголовочний файл містить оголошення потоків, таких як std::cout, які використовуються для виведення інформації.
using namespace std;          // Дозволяє не писати "std::" перед кожним використанням об’єктів стандартної бібліотеки.

int main(void) {              // Функція main – точка входу в програму. Аргумент void означає, що функція не приймає параметрів.
    
    // Оголошення двовимірного масиву "matrix" розміром 10х10.
    // Усі 100 елементів типу int ініціалізуються нулями за замовчуванням.
    int matrix[10][10] = { };
    
    // ===================== Заповнення матриці таблицею множення за допомогою вказівників =====================
    
    // Отримання адреси першого елемента матриці.
    // В C++ ім'я масиву (matrix) при використанні в контексті виразу "decays" (перетворюється) в адресу першого елемента.
    // Але важливо: "matrix" має тип "int [10][10]", а при перетворенні вказівником – тип "int (*)[10]".
    // Ми хочемо отримати лінійний покажчик на тип int, тому використовуємо оператор адреси для першого елемента.
    int *ptr = &matrix[0][0];
    // Тут "ptr" містить адресу першого елемента матриці, наприклад, 0x1000 (умовне значення). 
    // Це дозволяє працювати з матрицею як з послідовним блоком пам'яті, що містить 100 елементів.
    
    // Обчислення кінцевої адреси, тобто адреси, що знаходиться одразу після останнього елемента матриці.
    // Оскільки в матриці 10*10 = 100 елементів, ми додаємо 100 до початкової адреси.
    // Арифметика вказівників враховує розмір типу: ptr + 100 збільшує адресу на 100 * sizeof(int) байтів.
    int *end = ptr + 100;
    // Наприклад, якщо sizeof(int) дорівнює 4 байти, то відстань між ptr і end буде 400 байт.
    
    // Починаємо обхід всіх елементів матриці за допомогою вказівників.
    // Цикл працює, поки поточна адреса (ptr) знаходиться перед кінцевою адресою (end).
    while (ptr < end) {
        
        // Обчислення зміщення (offset) поточного елемента від початку матриці.
        // Операція (ptr - &matrix[0][0]) повертає кількість елементів між поточним положенням і початком.
        // Це арифметична операція над вказівниками, яка відбувається на рівні машинного коду шляхом віднімання значень адрес.
        int offset = ptr - &matrix[0][0];
        
        // Обчислення номера рядка (row) поточного елемента.
        // Оскільки матриця має 10 елементів у кожному рядку, цілочисельний поділ offset на 10 дає номер рядка.
        int row = offset / 10;
        
        // Обчислення номера стовпця (col) поточного елемента.
        // Операція offset % 10 (залишок від ділення) дає позицію елемента в межах рядка, тобто номер стовпця.
        int col = offset % 10;
        
        // Обчислення значення для поточного елемента згідно таблиці множення.
        // Оскільки множення починається з 1, додаємо 1 до номера рядка та стовпця.
        // Таким чином, для першого рядка (row = 0) і першого стовпця (col = 0) обчислюється: (0 + 1) * (0 + 1) = 1,
        // для елемента в другому стовпці першого рядка: (0 + 1) * (1 + 1) = 2, і т.д.
        *ptr = (row + 1) * (col + 1);
        // Розіменування (*ptr) означає, що ми отримуємо доступ до даних, які зберігаються за адресою, що міститься у вказівнику "ptr".
        // На машинному рівні ця операція завантажує значення з конкретного місця в оперативній пам’яті в регістр процесора.
        
        // Перехід до наступного елемента в послідовному блоці пам'яті.
        // Оператор інкременту (ptr++) додає до поточної адреси розмір типу int (наприклад, 4 байти),
        // завдяки чому вказівник переміщується до наступного елемента матриці.
        ptr++;
        // На рівні машинного коду це реалізовано як арифметичне додавання до значення регістру, що містить адресу.
    }
    
    // ===================== Завершення заповнення матриці таблицею множення =====================
    
    // Вивід матриці за допомогою вкладених циклів з використанням індексації.
    // Тут ми використовуємо індексацію для виводу, оскільки вимога щодо використання виключно вказівників стосується лише заповнення.
    for (int i = 0; i < 10; i++) {      // Зовнішній цикл перебирає рядки матриці.
        for (int j = 0; j < 10; j++) {  // Внутрішній цикл перебирає стовпці для кожного рядка.
            cout.width(4);            // Встановлюємо ширину поля для вирівнювання виведених чисел.
            cout << matrix[i][j];     // Вивід елемента матриці. Тут індексація дозволена, оскільки вона лише для відображення.
        }
        cout << endl;                 // Після виводу одного рядка переходимо на новий рядок.
    }
    
    return 0;  // Повертаємо 0, що означає успішне завершення програми. Це значення повертається операційній системі.
}
