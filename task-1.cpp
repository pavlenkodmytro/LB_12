#include <iostream>  // Підключення бібліотеки вводу/виводу. 
                       // На рівні компіляції це дозволяє використовувати функції стандартної бібліотеки для роботи зі стандартними потоками,
                       // такі як std::cout, std::endl, що в подальшому перетворюються у виклики системних функцій ОС.

using namespace std; // Використання простору імен std для спрощення коду: не потрібно писати std:: перед кожною стандартною функцією чи об'єктом.

int main(void) {     // Початок функції main, яка є точкою входу в програму.
                     // Аргумент void вказує, що функція не приймає параметрів.
                     // На рівні машинного коду це означає, що при запуску програми операційна система не передає параметри в регістри або стек.

    // Оголошення статичного масиву цілих чисел.
    // Компоновщик виділяє під масив "vector" послідовний блок пам'яті, де кожен елемент має тип int.
    // При компіляції ім'я "vector" асоціюється з адресою першого елемента цього блоку.
    int vector[] = { 3, -5, 7, 10, -4, 14, 5, 2, -13 };
    
    // Обчислення кількості елементів у масиві:
    // - sizeof(vector) повертає загальний розмір масиву в байтах.
    // - sizeof(vector[0]) повертає розмір одного елемента (типу int) в байтах.
    // Ділення цих значень дає точну кількість елементів, оскільки всі елементи мають однаковий розмір.
    // На рівні машинного коду це виконується як арифметична операція над константами, визначеними на етапі компіляції.
    int n = sizeof(vector) / sizeof(vector[0]);
    
    // Оголошення вказівника на int для обходу масиву.
    // Ініціалізація "ptr = vector" – оскільки ім'я масиву в контексті виразу перетворюється (decays) на адресу першого елемента.
    // На рівні машинного коду "ptr" отримує значення адреси, наприклад, 0x1000 (умовне значення) – це початкова адреса блоку пам'яті для масиву.
    int* ptr = vector;
    
    // Оголошення вказівника, який буде зберігати адресу найменшого елемента.
    // Спочатку він встановлюється на початок масиву (адреса першого елемента), тому що спочатку вважаємо, що перший елемент є мінімальним.
    // Фактично, "min_ptr" містить ту ж адресу, що й "ptr".
    int* min_ptr = vector;
    
    // Обчислення кінцевої адреси масиву, яка знаходиться одразу за останнім елементом.
    // Арифметика вказівників враховує розмір типу: vector + n означає, що до базової адреси масиву додається n * sizeof(int) байтів.
    // Це дозволяє нам встановити вказівник, який служить умовою завершення циклу.
    // На рівні машинного коду ця операція виконується як додавання константного зсуву до регістру, що містить адресу.
    int* end = vector + n;
    
    // Цикл для обходу масиву за допомогою вказівника.
    // Умова циклу "ptr < end" перевіряє, що поточна адреса, на яку вказує "ptr", знаходиться перед кінцевою адресою.
    // Порівняння вказівників відбувається за їх числовими значеннями (адресами в пам'яті).
    while (ptr < end) {
        
        // Розіменування вказівника (*ptr) дозволяє отримати значення, що зберігається в пам'яті за даною адресою.
        // Тут ми порівнюємо значення поточного елемента (*ptr) з поточним мінімальним значенням (*min_ptr).
        // На рівні машинного коду це означає завантаження значень з певних адрес в регістри процесора та виконання порівняльної операції.
        if (*ptr < *min_ptr) {
            // Якщо поточний елемент є меншим за знайдений до цього мінімальний,
            // оновлюємо вказівник "min_ptr", присвоюючи йому адресу поточного елемента (значення "ptr").
            // Операція присвоєння – це копіювання значення адреси, яке займає декілька байтів (зазвичай 4 або 8 байтів залежно від архітектури).
            min_ptr = ptr;
        }
        
        // Інкремент вказівника "ptr" для переходу до наступного елемента масиву.
        // Ця операція додає до поточної адреси розмір типу int (sizeof(int) байтів).
        // На машинному рівні це реалізується як арифметичне додавання: регістр, що містить адресу, збільшується на константу.
        ptr++;
    }
    
    // Вивід результату за допомогою стандартного потоку виводу (std::cout).
    // Розіменування "(*min_ptr)" отримує значення за адресою, яка містить найменший елемент масиву.
    // Цей рядок з'єднує текстове повідомлення з числовим значенням і завершується символом нового рядка (endl).
    // На рівні машинного коду виклик cout передається через функції бібліотеки, що в свою чергу викликають системні виклики для виводу на екран.
    cout << "The smallest item in the array is " << *min_ptr << endl;
    
    // Завершення роботи функції main, повернення значення 0 позначає, що програма виконалася успішно.
    // Це значення повертається операційній системі.
    return 0;
}
